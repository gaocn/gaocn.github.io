---
layout:     post
title:      "Android性能实践"
subtitle:   "一天进步一点点！"
date:       2016-10-26
author:     "Govind"
header-img: "img/post_bg/18.jpg"
tags:
    - Android性能
---


---

# TL;DR

高性能程序的特点是什么？怎么样能够写过不被OOM临幸的应用？或者，事后诸葛亮，在程序出现内存占用量较大时候，应该如何查找出现的问题，保证程序快快乐乐的在你的移动设备上跑着！好的应用程序不仅要求功能满足需求，还好保证性能的恰到好处。
Android系统的虚拟机虽然拥有自动回收机制，但是并不是代表我们需要需要去关注内存的分配和释放。编码过程中，需要注意今年避免内存泄露的问题，该问题通常是由于全局成员变量持有的对象引用所导致，要在适当时候释放对象引用。


# 合理管理内存
  1. 节制的使用Service，只有当任务正在执行时才运行Service，当任务执行完后要停止Service，需要注意的是：停止Service失败会导致内存泄露。启动一个 Service后，系统会尽可能保留Service说依赖的进程，因此Service通常会非常消耗内存，只有在系统内存吃紧时，才会按照空进程、后台进程、服务进程、可视进程、前台进程的顺序释放进程所占用的空间。系统采用LRU Cahce缓存进程，因此Service进程多的话，会影响其他应用程序，导致应用程序进程切换时消耗更多性能，甚至导致系统崩溃。
  为了能够控制Service的生命周期，Android官方推荐使用[IntentService][3]，其特点就是当后台任务结束后，该Service会自动停止，从而能够避免Service内存泄露。
  最佳实践：除非必要，不要让Service在后台一直运行！
  2. 界面不可见时释放内存， onTrimMemory方法中的TRIM_MEMORY_UI_HIDDEN回调会当程序中的所有UI组件都不可见时才会才会调用，此时表明用户已经离开了程序，可以进行资源的释放；与OnStop不同是，该方法会在Activity界面不可见时就调用，此时UI相关的资源还不能释放，需要所有UI完全不可见时才能够释放。
<pre>
  ```
  @override
  public void onTrimMemory(int level) {
    super.onTrimMemory();
    switch(level) {
      case TRIM_MEMORY_UI_HIDDEN:
      //今次那个资源释放
      break;
    }
  }
  ```
</pre>
  除了上面的一个回调函数，根据应用程序是否缓存还分为一以下回调：
  * TRIM_MEMORY_RUNNING_MODERATE, 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。
  * TRIM_MEMORY_RUNNING_LOW, 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。
  * TRIM_MEMORY_RUNNING_CRITICAL, 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。
  对于缓存的应用程序还有以下回调函数：
  * TRIM_MEMORY_BACKGROUND, 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。
  * TRIM_MEMORY_MODERATE, 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。
  * TRIM_MEMORY_COMPLETE, 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。
  3. 避免在Bitmap上浪费内存，图片的大小并不是加载到内存中的大小，图片是由像素构成，一个像素采用RGB要3个字节，通常会加上一个字节表示像素的透明度，因此一个像素大小是4B，因此一个图片像素为1500*1000的图像，占用内存大小为1500*1000*4 = 5.7MB，因此需要对图片进行缩放；并且在手机上显示这么大分辨率的图片也没有必要。
  4. 使用优化后的数据集合，Android API中提供了SparseArray、SparseBooelanArray比自定义的数据更高效，SparseArra避免了基本数据类型转换成对象数据类型的时间。
  5. 知道常用的内存开支情况，在软件设计和开发中要考虑进去：
    * 枚举类型会比静态类型常量消耗两倍以上的内存；
    * 任何一个Java类，包括内部类，匿名类，都要占用大概500B的内存空间；
    * 任何一个类的实例要消耗12~16B内存，因此不要频繁创建实例；
    * 使用HashMap时，虽然使用的是int类型作为键，实际上还是按照对象大小分配内存，大概32字节；
  6. 谨慎使用抽象编程，在Android中使用抽象编程会带来额外的开支，因此抽象的编程方法需要编写额外的代码，虽然代码不被执行但是会被映射到内存中；最佳实践：在必要合适的情况下使用抽象编程。
  7. 尽量避免使用依赖注入框架，该框架虽然是代码开起来简单了，省去了繁琐的findViewById操作，但是这些框架通常通过搜索代码中的注解，需要很长时间的初始化过程，并且可能会加载一些不使用的对象到内存。
  8. 使用ProGuard简化代码，ProGuard除了混淆Android代码，还可以对代码进行检索，删除一些无用的代码、并且对类、字段、方法重命名，使得一些方法、类名简短。
  9. 使用多个进程，但是要谨慎使用，大多数应用程序都不应该在多进程中运行，使用不当会增加额外内存，这种情况比较适用于那些需要在后台去完成一项独立任务，且和前台的功能是完全可以区分开的场景。实现方式，只需要在Android的Manifest文件的应用程序组件中生命一个android:process属性即可，例如：让一个播放音乐的Service组件可以单独运行在一个进程中，实现如下：
  <pre>
      &lt;Service android:name=".PlaybackService"android:process=":background" /&gt;
  </pre>
  上述例子中指定的进程名为background,可以任意修改，注意的是进程名前面需要加上冒号，表示进程是一个当前应用程序的私有进程。
  这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。

# 分析内存的使用情况

  每个程序都会有可使用的内存上限，这被称为堆大小（Heap Size）；如果大家想要知道自己手机的堆大小是多少，可以调用如下代码：
  <pre>
      ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
      int heapSize = manager.getMemoryClass();  
  </pre>
  结果是以MB为单位进行返回的，我们在开发应用程序时所使用的内存不能超出这个限制，否则就会出现OutOfMemoryError。因此，比如说我们的程序中需要缓存一些数据，就可以根据堆大小来决定缓存数据的容量。
  Android的GC操作，GC全称是Garbage Collection，GC操作会从一个叫作Roots的对象开始检查，所有它可以访问到的对象就说明还在使用当中，应该进行保留，而其它的对象就表示已经不再被使用了。
## 分析GC日志
  D/dalvikvm: [GC_Reason] [Amount_freed], [Heap_stats], [Pause_time]  
  首先第一部分 **GC_Reason**，这个是触发这次GC操作的原因，一般情况下一共有以下几种触发GC操作的原因：
    * GC_CONCURRENT: 当我们应用程序的堆内存快要满的时候，系统会自动触发GC操作来释放内存。
    * GC_FOR_MALLOC: 当我们的应用程序需要分配更多内存，可是现有内存已经不足的时候，系统会进行GC操作来释放内存。
    * GC_HPROF_DUMP_HEAP: 当生成HPROF文件的时候，系统会进行GC操作，关于HPROF文件我们下面会讲到。
    * GC_EXPLICIT: 这种情况就是我们刚才提到过的，主动通知系统去进行GC操作，比如调用System.gc()方法来通知系统。或者在DDMS中，通过工具按钮也是可以显式地告诉系统进行GC操作的。<br/>
  **Amount_freed** 表示系统通过这次GC操作释放了多少内存。<br/>
  **Heap_stats** 中会显示当前内存的空闲比例以及使用情况（活动对象所占内存 / 当前程序总内存）。<br/>
  **Pause_time** 表示这次GC操作导致应用程序暂停的时间。关于这个暂停的时间，Android在2.3的版本当中进行过一次优化，在2.3之前GC操作是不能并发进行的，也就是系统正在进行GC，那么应用程序就只能阻塞住等待GC结束。虽说这个阻塞的过程并不会很长，也就是几百毫秒，但是用户在使用我们的程序时还是有可能会感觉到略微的卡顿。而自2.3之后，GC操作改成了并发的方式进行，就是说GC的过程中不会影响到应用程序的正常运行，但是在GC操作的开始和结束的时候会短暂阻塞一段时间，不过优化到这种程度，用户已经是完全无法察觉到了。<br/>

  ![GC 日志][4]

# 后记


[1]:http://blog.csdn.net/sinyu890807/article/details/42238627          "Android最佳性能实践1"
[2]:http://blog.csdn.net/sinyu890807/article/details/42238633      "Android最佳性能实践2"
[3]: http://blog.csdn.net/guolin_blog/article/details/26365913 "IntentService使用"
[4]:
